package main

import (
	"context"
	"crypto/ecdsa"
	"errors"
	"fmt"
	"log"
	"math/big"
	"math/rand"
	"sync"
	"time"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
)

func main() {
	//rpcUrl = "https://exchaintestrpc.okex.org"
	chainID := big.NewInt(67)
	addr := "3DF95c73357f988F732c4c7a8Fa2f9beD7952861"
	fromPrivkey := "8ff3ca2d9985c3a52b459e2f6e7822b23e1af845961e22128d5f372fb9aa5f17"

	captionPk, err := crypto.HexToECDSA(fromPrivkey)
	CheckErr(err)
	transferOKT(chainID, big.NewInt(1000000000000000000), captionPk, addr)

	mStore := make([]*ecdsa.PrivateKey, 0)
	var mutex sync.Mutex
	for i := 0; i < 100000; i++ {
		privateKey, _ := crypto.GenerateKey()
		randAddr, _ := PrivateKeyToAddress(privateKey)
		transferOKT(chainID, big.NewInt(1000000000000000000), captionPk, randAddr.String())
		mStore = append(mStore, privateKey)
	}

	time.Sleep(3 * time.Second)
	var wg sync.WaitGroup
	const concurrent = 1000
	wg.Add(concurrent * 2)
	for i := 0; i < 1000; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < 100; j++ {
				privateKey, _ := crypto.GenerateKey()
				randAddr, _ := PrivateKeyToAddress(privateKey)
				mutex.Lock()
				pk := mStore[0]
				mStore = mStore[1:]
				mutex.Unlock()
				transferOKT(chainID, big.NewInt(1000000000000000000), pk, randAddr.String())
				time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
			}
		}()
	}
	for i := 0; i < 1000; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < 100; j++ {
				estimateGas(addr)
				time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
			}
		}()
	}
	wg.Wait()
}

func estimateGas(from string) {
loop:
	rpcUrl := "http://127.0.0.1:8545"
	client, err := ethclient.Dial(rpcUrl)
	if err != nil {
		log.Println("estimate dial error ", err)
		goto loop
	}
	defer client.Close()

	ctx := context.Background()
	msg := ethereum.CallMsg{
		From:     common.HexToAddress(from),
		To:       nil,
		Gas:      30000,
		GasPrice: big.NewInt(100000000),
		Data:     []byte{0x60, 0x80, 0x60, 0x40, 0x52, 0x34, 0x80, 0x15, 0x61, 0x00, 0x10, 0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x50, 0x61, 0x01, 0x50, 0x80, 0x61, 0x00, 0x20, 0x60, 0x00, 0x39, 0x60, 0x00, 0xf3, 0xfe, 0x60, 0x80, 0x60, 0x40, 0x52, 0x34, 0x80, 0x15, 0x61, 0x00, 0x10, 0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x50, 0x60, 0x04, 0x36, 0x10, 0x61, 0x00, 0x36, 0x57, 0x60, 0x00, 0x35, 0x60, 0xe0, 0x1c, 0x80, 0x63, 0x2e, 0x64, 0xce, 0xc1, 0x14, 0x61, 0x00, 0x3b, 0x57, 0x80, 0x63, 0x60, 0x57, 0x36, 0x1d, 0x14, 0x61, 0x00, 0x59, 0x57, 0x5b, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x61, 0x00, 0x43, 0x61, 0x00, 0x75, 0x56, 0x5b, 0x60, 0x40, 0x51, 0x61, 0x00, 0x50, 0x91, 0x90, 0x61, 0x00, 0xd9, 0x56, 0x5b, 0x60, 0x40, 0x51, 0x80, 0x91, 0x03, 0x90, 0xf3, 0x5b, 0x61, 0x00, 0x73, 0x60, 0x04, 0x80, 0x36, 0x03, 0x81, 0x01, 0x90, 0x61, 0x00, 0x6e, 0x91, 0x90, 0x61, 0x00, 0x9d, 0x56, 0x5b, 0x61, 0x00, 0x7e, 0x56, 0x5b, 0x00, 0x5b, 0x60, 0x00, 0x80, 0x54, 0x90, 0x50, 0x90, 0x56, 0x5b, 0x80, 0x60, 0x00, 0x81, 0x90, 0x55, 0x50, 0x50, 0x56, 0x5b, 0x60, 0x00, 0x81, 0x35, 0x90, 0x50, 0x61, 0x00, 0x97, 0x81, 0x61, 0x01, 0x03, 0x56, 0x5b, 0x92, 0x91, 0x50, 0x50, 0x56, 0x5b, 0x60, 0x00, 0x60, 0x20, 0x82, 0x84, 0x03, 0x12, 0x15, 0x61, 0x00, 0xb3, 0x57, 0x61, 0x00, 0xb2, 0x61, 0x00, 0xfe, 0x56, 0x5b, 0x5b, 0x60, 0x00, 0x61, 0x00, 0xc1, 0x84, 0x82, 0x85, 0x01, 0x61, 0x00, 0x88, 0x56, 0x5b, 0x91, 0x50, 0x50, 0x92, 0x91, 0x50, 0x50, 0x56, 0x5b, 0x61, 0x00, 0xd3, 0x81, 0x61, 0x00, 0xf4, 0x56, 0x5b, 0x82, 0x52, 0x50, 0x50, 0x56, 0x5b, 0x60, 0x00, 0x60, 0x20, 0x82, 0x01, 0x90, 0x50, 0x61, 0x00, 0xee, 0x60, 0x00, 0x83, 0x01, 0x84, 0x61, 0x00, 0xca, 0x56, 0x5b, 0x92, 0x91, 0x50, 0x50, 0x56, 0x5b, 0x60, 0x00, 0x81, 0x90, 0x50, 0x91, 0x90, 0x50, 0x56, 0x5b, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x61, 0x01, 0x0c, 0x81, 0x61, 0x00, 0xf4, 0x56, 0x5b, 0x81, 0x14, 0x61, 0x01, 0x17, 0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x50, 0x56, 0xfe, 0xa2, 0x64, 0x69, 0x70, 0x66, 0x73, 0x58, 0x22, 0x12, 0x20, 0x9a, 0x15, 0x9a, 0x4f, 0x38, 0x47, 0x89, 0x0f, 0x10, 0xbf, 0xb8, 0x78, 0x71, 0xa6, 0x1e, 0xba, 0x91, 0xc5, 0xdb, 0xf5, 0xee, 0x3c, 0xf6, 0x39, 0x82, 0x07, 0xe2, 0x92, 0xee, 0xe2, 0x2a, 0x16, 0x64, 0x73, 0x6f, 0x6c, 0x63, 0x43, 0x00, 0x08, 0x07, 0x00, 0x33},
	}
	count, err := client.EstimateGas(ctx, msg)
	if err != nil {
		log.Println("estimate error", err)
	}
	log.Println("estimate ok-----", count)
}

func CheckErr(err error) {
	if err != nil {
		panic(err)
	}
}

func transferOKT(chainID *big.Int, value *big.Int, from *ecdsa.PrivateKey, to string) {
loop:
	rpcUrl := "http://127.0.0.1:8545"
	client, err := ethclient.Dial(rpcUrl)
	if err != nil {
		log.Println("transferOKT error", err)
		goto loop
	}

	privateKey := from
	CheckErr(err)
	fromAddr, err := PrivateKeyToAddress(privateKey)
	CheckErr(err)
	nonce, err := client.PendingNonceAt(context.Background(), fromAddr)
	if err != nil {
		log.Println("----nonce", err)
	}
	fmt.Println(nonce)

	toAddr := common.HexToAddress(to)
	tx := types.NewTransaction(nonce, toAddr, value, 30000, big.NewInt(100000000), nil)
	signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
	CheckErr(err)
	err = client.SendTransaction(context.Background(), signedTx)
	if err != nil {
		log.Println("send transaction error", err)
	}
	fmt.Printf("tx sent: %s\n", signedTx.Hash().Hex())
}

func PrivateKeyToAddress(privateKey *ecdsa.PrivateKey) (common.Address, error) {
	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		return common.Address{}, errors.New("error casting public key to ECDSA")
	}
	address := crypto.PubkeyToAddress(*publicKeyECDSA)
	return address, nil
}
